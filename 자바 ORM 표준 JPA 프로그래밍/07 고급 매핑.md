# 7.1 상속 관계 매핑
- 관계형 데이터베이스에는 객체지향 언어에서 다루는 상속이라는 개념이 없다.
- 대신 슈퍼타입 서브타입 관계라는 모델링 기법이 있다.
- 슈퍼타입 서브타입 논리 모델을 실제 물리 모델인 테이블로 구현할 때는 3가지 방법이 있다.
1. 각각의 테이블로 변환(조인 전략)
2. 통합 테이블로 변환(단일 테이블 전략)
3. 서브타입 테이블로 변환(구현 클래스마다 테이블 전략)

<br/>

## 7.1.1 조인 전략
- 엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본 키를 받아서 기본키+외래키로 사용하는 전략이다.
- 조회할 때 조인을 자주 사용한다.
- 객체는 타입으로 구분할 수 있지만 테이블은 타입의 개념이 없다. 따라서 타입을 구분하는 컬럼을 추가해야 한다.
```java
@Entity
@Inheritance(strategy=InheritanceType.JOINED)
@DiscriminatorColumn(name="DTYPE")
public abstract class Item {

  @Id
  @GeneratedValue
  @Column(name="ITEM_ID")
  private Long id;

  private String name;
  private int price;
  ...
}

@Entity
@DiscriminatorValue("A")
public class Album extends Item {

  private String artist;
  ...
}

@Entity
@DiscriminatorValue("M")
public class Movie extends Item {

  private String director;
  private String actor;
  ...
}
```

- `@Inheritance(strategy=InheritanceType.JOINED)`
  - 상속 매핑은 부모 클래스에 `@Inheritance`를 사용해야 한다.
- `@DiscriminatorColumn(name="DTYPE")
  - 부모 클래스에 구분 컬럼을 지정한다.
  - 이 컬럼으로 저장된 자식 테이블을 구분할 수 있다.
  - 기본값이 DTYPE이므로 `@DiscriminatorColumn`으로 줄여 사용해도 된다.
- `@DiscriminatorValue("M")
  - 엔티티를 저장할 때 구분 컬럼에 입력할 값을 지정한다.

```java
@Entity
@DiscriminatorValue("B")
@PrimaryKeyJoinColumn(name="BOOK_ID")
public class Book extends Item {

  private String author;
  private String isbn;
  ...
}
```
- 기본값으로 자식 테이블은 부모 테이블의 ID 컬럼명을 그대로 사용
- 만약 자식 테이블의 기본키 컬럼명을 변경하고 싶으면 `@PrimaryKeyJoinColumn`을 사용한다.

✅ 장점
- 테이블이 정규화된다.
- 외래키 참조 무결성 제약조건을 활용할 수 있다
- 저장공간을 효율적으로 사용한다

✅ 단점
- 조회할 때 조인이 많이 사용되므로 성능이 저하될 수 있다
- 조회 쿼리가 복잡하다
- 데이터를 등록할 INSERT SQL을 두 번 실행한다

<br/>

## 7.1.2 단일 테이블 전략
- 테이블을 하나만 사용한다.
- 구분 컬럼으로 어떤 자식 데이터가 저장되었는지 구분한다.
- 조회할 때 조인을 사용하지 않으므로 일반적으로 가장 빠르다.
- 주의할 점은 자식 엔티티가 매핑한 컬럼은 모두 `null`을 허용해야 한다는 점이다.

```java
@Entity
@Inheritance(strategy=InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name="DTYPE")
public abstract class Item {

  @Id
  @GeneratedValue
  @Column(name="ITEM_ID")
  private Long id;

  private String name;
  private int price;
  ...
}

@Entity
@DiscriminatorValue("A")
public class Album extends Item {...}

@Entity
@DiscriminatorValue("M")
public class Movie extends Item {...}

@Entity
@DiscriminatorValue("B")
public class Book extends Item {...}
```

- 테이블 하나에 모든 것을 통합하므로 구분 컬럼을 필수로 사용해야 한다.

✅ 장점
- 조인이 필요 없으므로 일반적으로 조회 성능이 빠르다
- 조회 쿼리가 단순하다

✅ 단점
- 자식 엔티티가 매핑한 컬럼은 모두 `null`을 허용해야 한다.
- 단일 테이블에 모든 것을 저장하므로 테이블이 커져, 상황에 따라서는 조회 성능이 오히려 느려질 수 있다.

<br/>

## 7.1.3 구현 클래스마다 테이블 전략
```java
@Entity
@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)
public abstract class Item {

  @Id
  @GeneratedValue
  @Column(name="ITEM_ID")
  private Long id;

  private String name;
  private int price;
  ...
}

@Entity
public class Album extends Item {...}

@Entity
public class Movie extends Item {...}

@Entity
public class Book extends Item {...}
```
- 자식 엔티티마다 테이블을 만드는 전략이다.
- **일반적으로 추천하지 않는 전략이다.**

✅ 장점
- 서브 타입을 구분해서 처리할 때 효과적이다
- `not null` 제약조건을 사용할 수 있다

✅ 단점
- 여러 자식 테이블을 함께 조회할 때 성능이 느리다(SQL에서 UNION을 사용해야 한다)
- 자식 테이블을 통합해서 쿼리하기 어렵다.

<hr/>

# 7.2 @MappedSuperclass
- 부모 클래스는 테이블과 매핑하지 않고 부모 클래스를 상속받는 자식 클래스에게 매핑 정보만 제공하고 싶을 때 사용한다.
- 실제 테이블과 매핑되지 않고, 단순히 매핑 정보를 상속할 목적으로만 사용된다.
```java
@MappedSuperclass
public abstract class BaseEntity {

  @Id
  @GeneratedValue
  private Long id;
  private String name;
  ...
}

@Entity
public class Member extends BaseEntity {

  // ID 상속
  // NAME 상속
  private String email;
  ...
}

@Entity
public class Seller extends BaseEntity {

  // ID 상속
  // NAME 상속
  private String shopName;
  ...
}
```

- BaseEntity에는 객체들이 주로 사용하는 공통 매핑 정보를 정의했다.
- 자식 엔티티들은 상속을 통해 BaseEntity의 매핑 정보를 물려받았다.
- 부모로부터 물려받은 매핑 정보를 재정의하려면 `@AttributeOverrides`나 `@AttributeOverride`를 사용한다.
- 연관관계를 재정의하려면 `@AssociationOverrides`나 `@AssociationOverride`를 사용한다.
```java
@Entity
@AttributeOverrides({
  @AttribuateOverride(name="id", column=@Column(name="MEMBER_ID")),
  @AttribuateOverride(name="name", column=@Column(name="MEMBER_NAME"))
})
public class Member extends BaseEntity {...}
```
- **테이블과 매핑되지 않고** 자식클래스에 엔티티의 매핑 정보를 상속하기 위해 사용한다.
- `@MappedSuperclass`로 지정한 클래스는 **엔티티가 아니므로 `em.find()`나 JPQL에서 사용할 수 없다.**
- 테이블과는 관게가 없고 단순히 에닡티가 공통으로 사용하는 매핑 정보를 모아주는 역할을 할 뿐이다.
- 이 클래스는 직접 생성해서 사용할 일은 거의 없으므로 **추상 클래스로 만드는 것을 권장**한다.

<hr/>

# 7.3 복합 키와 식별 관계 매핑

## 7.3.1 식별 관계 vs 비식별 관계
- 필수적 비식별 관계(Mandatory): 외래키에 NULL을 허용하지 않는다. 연관관계를 필수적으로 맺어야 한다.
- 선택적 비식별 관계(Optional): 외래키에 NULL을 허용한다. 연관관계를 맺을지 말지 선택할 수 있다.
- 최근에는 비식별 관계를 주로 사용하고 꼭 필요한 곳에만 식별 관계를 사용하는 추세다.
