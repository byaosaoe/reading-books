- 방향(Direction)
  - 단방향, 양방향이 있다.
  - 방향은 객체관계에만 존재하고 테이블 관계는 항상 양방향이다.
- 다중성(Multiplicity)
  - 다대일, 일대다, 일대일, 다대다 다중성이 있다.
- 연관관계의 주인(owner)
  - 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 한다.
 
<hr/>

# 5.1 단방향 연관관계
- 객체 연관관계와 테이블 연관관계의 가장 큰 차이
  - 참조를 통한 연관관계를 언제나 단방향이다.
  - 객체간에 연관관계를 양방향으로 만들고 싶으면 서로 다른 단방향 관계 2개를 만들어야 한다.
  - 반면에 테이블은 외래키 하나로 양방향으로 조인할 수 있다.
 
## 5.1.2 테이블 연관관계

```sql
CREATE TABLE MEMBER (
  MEMBER_ID VARCHAR(255) NOT NULL,
  TEAM_ID VARCHAR(255),
  USERNAME VARCHAR(255),
  PRIMARY KEY (MEMBER_ID)
)

CREATE TABLE TEAM (
  TEAM_ID VARCHAR(255) NOT NULL,
  NAME VARCHAR(255),
  PRIMARY KEY (TEAM_ID)
)

ALTER TABLE MEMBER ADD CONSTRAINT FK_MEMBER_TEAM
  FOREIGN KEY (TEAM_ID)
  REFERENCES TEAM
```

<hr/>

## 5.1.3 객체 관계 매핑

### 매핑한 회원 엔티티

```java
@Entity
public class Member {

  @Id
  @Column(name="MEMBER_ID")
  private String id;

  private String username;

  // 연관관계 매핑
  @ManyToOne
  @JoinColumn(name="TEAM_ID")
  private Team team;

  // 연관관계 설정
  public void setTeam(Team team) {
    this.team = team;
  }

  // Getter, Setter ...
}
```

### 매핑한 팀 엔티티
```java
@Entity
public class Team {

  @Id
  @Column(name = "TEAM_ID")
  private String id;

  private String name;

  // Getter, Setter ...
}
```

- 객체 연관관계: 회원 객체의 `Member.team` 필드 사용
- 테이블 연관관계: 회원 테이블의 `MEMBER.TEAM_ID` 외래 키 컬럼을 사용

<hr/>

## 5.1.4 @JoinColumn

- 외래 키를 매핑할 때 사용한다.

|속성|기능|기본값|
|:---|:---|:---|
|name|매핑할 외래 키 이름|필드명 + _ + 참조하는 테이블의 기본 키 컬럼명|
|referencedColumnName|외래 키가 참조하는 대상 테이블의 컬럼명|참조하는 테이블의 기본키 컬럼명|
|foreignKey(DDL)|외래키 제약조건을 직접 지정할 수 있다. 이 속성은 테이블을 생성할 때만 사용한다.||

- 위의 코드에서 `@JoinColumn`을 생략하면 외래키를 찾을 때 `team_TEAM_ID`를 사용한다.

<hr/>

## 5.1.5 @ManyToOne

|속성|기능|기본값|
|:---|:---|:---|
|optional|false로 설정하면 연관된 엔티티가 항상 있어야 한다.|true|
|fetch|글로벌 페치 전략을 설정한다.| - `@ManyToOne=FetchType.EAGER`<br/>- `@OneToMany=FetchType.LAZY`|
|cascade|영속성 전이 기능을 사용한다.||
|targetEntity|연관된 엔티티의 타입 정보를 설정한다. 이 기능은 거의 사용하지 않는다. 컬렉션을 사용해도 제네릭으로 타입 정보를 알 수 있다.||

<hr/>

# 5.2 연관관계 사용

## 5.2.1 저장

```java
public void testSave() {

  // 팀1 저장
  Team team1 = new Team("team1", "팀1");
  em.persist(team1);

  // 회원1 저장
  Member member1 = new Member("member1", "회원1");
  member1.setTeam(team1);
  em.persist(member1);

  // 회원2 저장
  Member member2 = new Member("member2", "회원2");
  member2.setTeam(team1);
  em.persist(member2);
}
```

- JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야 한다.

<hr/>

## 5.2.2 조회

연관관계가 있는 엔티티를 조회하는 방법은 크게 2가지다.
1. 객체 그래프 탐색(객체 연관관계를 사용한 조회)
2. 객체지향 쿼리 사용(JPQL)
```java
private static void queryLogicJoin(EntityManager em) {

  String jpql = "select m from Member m join m.team t where " + "t.name=:teamName";

  List<Member> resultList = em.createQuery(jpql, Member.class)
    .setParameter("teamName", "팀1")
    .getResultList();

  for (Member member: resultList) {
    System.out.println("[query] member.username=" + member.getUsername());
  }
}
// 결과: [query] member.username=회원1
// 결과: [query] member.username=회원2
```
