# 10.1 객체지향 쿼리 소개
- 데이터는 데이터베이스에 있으므로 SQL로 필요한 내용을 최대한 걸러서 조회해야 한다. 하지만 ORM을 사용하면 데이터베이스 테이블이 아닌 엔티티 객체를 대상으로 개발하므로 검색도 테이블이 아닌 엔티티 객체를 대상으로 하는 방법이 필요하다.
- JPQL은 이런 문제를 해결하기 위해 만들어졌는데 다음과 같은 특징이 있다.
1. 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리다.
2. SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.
- JPQL을 사용하면 JPA는 이 JPQL을 분석한 다음 적절한 SQL을 만들어 데이터베이스를 조회한다. 그리고 조회한 결과로 엔티티 객체를 생성해서 반환한다.

<br/>

## 10.1.1 JPQL 소개
- 엔티티 객체를 조회하는 객체지향 쿼리다.
- JPQL은 SQL을 추상화해서 특정 데이터베이스에 의존하지 않는다.
- 데이터베이스 방언만 변경하면 JPQL을 수정하지 않아도 자연스럽게 데이터베이스를 변경할 수 있다.
- JPQL은 SQL보다 간결하다.

```java
String jpql = "select m from Member as m where m.username='kim'";
List<Member> resultList = em.createQuery(jpql, Member.class).getResultList();
```
```sql
select
  member.id as id,
  member.age as age,
  member.team_id as team,
  member.name as name
from
  Member member
where
  member.name='kim'
```

<br/>

## 10.1.2 Criteria 쿼리 소개
- Criteria는 JPQL을 생성하는 빌더 클래스다.
- 장점은 문자가 아닌 프로그래밍 코드로 JPQL을 작성할 수 있다는 점이다.
- 문자기반 쿼리의 단점은 코드에 오타가 있어도 컴파일은 성공하고 쿼리가 실행되는 런타임 시점에 오류가 발생한다는 점이다.
- 코드로 JPQL을 작성하면 컴파일 시점에 오류를 발견할 수 있다.
1. 컴파일 시점에 오류를 발견할 수 있다.
2. IDE를 사용하면 코드 자동완성을 지원한다.
3. 동적 쿼리를 작성하기 편하다.
```java
// Criteria 사용 준비
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);

// 루트 클래스 (조회를 시작할 클래스)
Root<Member> m =query.from(Member.class);

// 쿼리 생성
CriteriaQuery<Member> cq = query.select(m).where(cb.equal(m.get("username"), "kim"));
List<Member> resultList = em.createQuery(cq).getResultList();
```
- 아쉬운 점은 `m.get("username")`에서 필드 명을 문자로 작성했다. 만약 이 부분도 문자가 아닌 코드로 작성하고 싶으면 메타 모델을 사용하면 된다.
```java
// 메타 모델 사용 전 -> 사용 후
m.get("username") -> m.get(Member_.username)
```
- Criteria가 가진 장점이 많지만 모든 장점을 상쇄할 정도로 복잡하고 장황하다.

<br/>

## 10.1.3 QueryDSL 소개
- JPQL 빌더 역할을 한다.
- 코드 기반이면서 단순하고 사용하기 쉽다는 장점이 있다.
- 작성한 코드도 JPQL과 비슷해서 한눈에 들어온다.
- JPA 표준은 아니고 오픈소스 프로젝트이다.

```java
// 준비
JPAQuery query = new JPAQuery(em);
QMember member = QMember.member;

// 쿼리, 결과조회
List<Member> members = query.from(member)
                            .where(member.username.eq("kim"))
                            .list(member);
```
- QueryDSL도 어노테이션 프로세서를 사용해서 쿼리 전용 클래스를 만들어야 한다.

<br/>

## 10.1.4 네이티브 SQL 소개
- JPA는 SQL을 직접 사용할 수 있는 기능을 지원하는데 이것을 네이티브 SQL이라 한다.
- 가끔 특정 데이터베이스에 의존하는 기능을 사용하거나 SQL은 지원하지만 JPQL는 지원하지 않는 기능을 사용해야 할 때가 있다.
- 네이티브 SQL의 단점은 특정 데이터베이스에 의존하는 SQL을 작성해야 한다는 것이다. 따라서 데이터베이스를 변경하면 네이티브 SQL도 수정해야 한다.
```java
String sql = "SELECT ID, AGE, TEAM_ID, NAME FROM MEMBER WHERE NAME = 'kim'";
List<Member> resultList = em.createNativeQuery(sql, Member.class).getResultList();
```

<br/>

## 10.1.5 JDBC 직접 사용, 마이바티스 같은 SQL 매퍼 프레임워크 사용
- JDBC 커넥션에 직접 접근하고 싶으면 JPA는 JDBC 커넥션을 획득하는 API를 제공하지 않으므로 JPA 구현체가 제공하는 방법을 사용해야 한다.
```java
Session session = entityManager.unwrap(Session.class);
session.doWork(new Work() {

  @Override
  public void execute(Connection connection) throws SQLException {
    // work...
  }
});
```
- JDBC나 마이바티스를 JPA와 함께 사용하면 영속성 컨텍스트를 적절한 시점에 강제로 플러시해야한다.
- JDBC를 직접 사용하든 마이바티스 같은 SQL 매퍼와 사용하든 모두 JPA를 우회해서 데이터베이스에 접근한다. 문제는 JPA를 우회하는 SQL에 대해서는 JPA가 전혀 인식하지 못한다는 점이다.
- 최악의 경우 영속성 컨텍스트와 데이터베이스를 불일치 상태로 만들어 데이터 무결성을 훼손할 수 있다.
- 이런 이슈를 해결하는 방법은 JPA를 우회해서 SQL을 실행하기 직전에 영속성 컨텍스트를 수동으로 플러시해서 데이터베이스와 영속성 컨텍스트를 동기화하면 된다.
- 스프링 프레임워크를 사용하면 JPA와 마이바티스를 손쉽게 통합할 수 있다.
- 또한 스프링 프레임워크의 AOP를 적절히 활용해서 JPA를 우회하여 데이터베이스에 접근하는 메소드를 호출할 때마다 영속성 컨텍스트를 플러시하면 위에서 언급한 문제도 해결할 수 있다.

<hr/>

# 10.2 JPQL
1. JPQL은 객체지향 쿼리 언어다. 따라서 테이블이 아닌 엔티티 객체를 대상으로 쿼리한다.
2. JPQL은 SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.
3. JPQL은 결국 SQL로 변환된다.

<br/>

## 10.2.1 기본 문법과 쿼리 API
```java
select_문 : : =
  select_절
  from_절
  [where_절]
  [groupby_절]
  [having_절]
  [orderby_절]

update_문 : : = update_절 [where_절]
delete_문 : : = delete_절 [where_절]
```

### ◼ SELECT 문
> SELECT m FROM Member AS m where m.username = 'Hello'

- 대소문자 구분
  - 엔티티와 속성은 대소문자를 구분한다.
  - 반면에 SELECT, FROM, AS 같은 JPQL 키워드는 대소문자를 구분하지 않는다.
- 엔티티 이름
  - 엔티티 명을 지정하지 않으면 클래스명을 기본값으로 사용한다.
  - 기본값인 클래스 명을 엔티티 명으로 사용하는 것을 추천한다.
- 별칭은 필수
  - JPQL은 별칭을 필수로 사용해야 한다.
  - AS는 생략할 수 있다.
 
### ◼ TypeQuery, Query
- 작성한 JPQL을 실행하려면 쿼리 객체를 만들어야 한다.
- 반환할 타입을 명확하게 지정할 수 있으면 TypeQuery 객체를 사용하고, 반환 타입을 명확하게 지정할 수 없으면 Query 객체를 사용하면 된다.
```java
TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m", Member.class);

List<Member> resultList = query.getResultList();
for (Member member : resultList) {
  System.out.println("member = " + member);
}
```
- `em.createQuery()`의 두 번째 파라미터에 반환할 타입을 지정하면 TypeQuery를 반환하고 지정하지 않으면 Query를 반환한다.

```java
Query query = em.createQuery("SELECT m.username, m.age FROM Member m");
List resultList = query.getResultList();

for (Object o : resultList) {
  Object[] result = (Object[]) o; // 결과가 둘 이상이면 Object[] 반환. 하나면 Object 반환.
  System.out.println("username = " + result[0]);
  System.out.println("age = " + result[1]);
}
```

<br/>

## 10.2.2 파라미터 바인딩

### ◼ 이름 기준 파라미터
- 파라미터를 이름으로 구분하는 방법
```java
String usernameParam = "User1";

TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m where m.username = :username", Member.class);

query.setParameter("username", usernameParam);
List<Member> resultList = query.getResultList();

or

List<Member> members = em.createQuery("SELECT m FROM Member m where m.username = :username", Member.class)
                          .setParameter("username", usernameParam)
                          .getResultList();
```

<br/>

### ◼ 위치 기준 파라미터
```java
List<Member> members = em.createQuery("SELECT m FROM Member m where m.username = ?1", Member.class)
                          .setParameter(1, usernameParam)
                          .getResultList();
```

- 위치 기준 파라미터 방식보다는 이름 기준 파라미터 바인딩 방식을 사용하는 것이 더 명확하다.

<br/>

## 10.2.3 프로젝션
### ◼ 엔티티 프로젝션
```java
SELECT m FROM Member m      // 회원
SELECT m.team FROM Member m // 팀
```
- 이렇게 조회한 엔티티는 영속성 컨텍스트에서 관리된다.

<br/>

### ◼ 임베디드 타입 프로젝션
- 임베디드 타입은 조회의 시작점이 될 수 없다는 제약이 있다.
```java
String query = "SELECT o.address FROM Order o";
List<Address> addresses = em.createQuery(query, Address.class)
                            .getResultList();
```
```sql
select
  order.city,
  order.street,
  order.zipcode
from
  Orders order
```
- 임베디드 타입은 엔티티 타입이 아닌 값 타입이다. 따라서 이렇게 직접 조회한 임베디드 타입은 영속성 컨텍스트에서 관리되지 않는다.

<br/>

### ◼ 스칼라 타입 프로젝션
- 숫자, 문자, 날짜와 같은 기본 데이터 타입들을 스칼라 타입이라 한다.
```java
List<String> usernames = em.createQuery("SELECT username FROM Member m", String.class)
                            .getResultList();
```
- 중복 데이터를 제거하려면 DISTINCT를 사용한다.
```java
SELECT DISTINCT username FROM Member m
```
- 통계 쿼리도 주로 스칼라 타입으로 조회한다.
```java
Double orderAmountAvg = em.createQuery("SELECT AVG(o.orderAmount) FROM Order o", Double.class)
                          .getSingleResult();
```

<br/>

### ◼ 여러 값 조회
```java
List<Object[]> resultList = em.createQuery("SELECT m.username, m.age FROM Member m")
                              .getResultList();

for (Object[] row : resultList) {
  String username = (String) row[0];
  Integer age = (Integer) row[1];
}
```

```java
List<Object[]> resultList = em.createQuery("SELECT o.member, o.product, o.orderAmount FROM Order o")
                              .getResultList();

for (Object[] row : resultList) {
  Member member = (Member) row[0];    // 엔티티
  Product product = (Product) row[1]; // 엔티티
  int orderAmount = (Integer) row[2]; // 스칼라
}
```
- 스칼라 타입뿐만 아니라 엔티티 타입도 여러 값을 조회할 수 있다.
- 이때도 조회한 엔티티는 영속성 컨텍스트에서 관리된다.

<br/>

### ◼ NEW 명령어
```java
List<Object[]> resultList = em.createQuery("SELECT m.username, m.age FROM Member m")
                              .getResultList();

// 객체 변환 작업
List<UserDTO> userDTOs = new ArrayList<UserDTO>();
for (Object[] row : resultList) {
  UserDTO userDTO = new UserDTO((String)row[0], (Integer)row[1]);
  userDTOs.add(userDTO);
}
return userDTOs;
```

```java
public class UserDTO {

  private String username;
  private int age;

  public UserDTO(String username, int age) {
    this.username = username;
    this.age = age;
  }
  // ...
}
```
- 이런 객체 변환 작업을 NEW 명령어를 사용해서 대체할 수 있다.

```java
TypedQuery<UserDTO> query = em.createQuery("SELECT new jpabook.jpql.UserDTO(m.username, m.age) FROM Member m", UserDTO.class);

List<UserDTO> resultList = query.getResultList();
```
- SELECT 다음에 NEW 명령어를 사용하면 반환받을 클래스를 지정할 수 있다.
- 이 클래스의 생성자에 JPQL 조회 결과를 넘겨줄 수 있다.
- NEW 명령어를 사용한 클래스로 TypeQuery를 사용할 수 있어서 지루한 객체 변환 작업을 줄일 수 있다.
- NEW 명령어를 사용할 때는 다음 2가지를 주의해야 한다.
1. 패키지 명을 포함한 저체 클래스 명을 입력해야 한다.
2. 순서와 타입이 일치하는 생성자가 필요하다.

<br/>

## 10.2.4 페이징 API
- JPA는 페이징을 다음 두 API로 추상화했다
1. `setFirstResult(int startPosition)`: 조회 시작 위치(0부터 시작한다)
2. `setMaxResults(int maxResult)`: 조회할 데이터 수

```java
TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m ORDER BY m.username DESC", Member.class);

query.setFirstResult(10);
query.setMaxResults(20);
query.getResultList();
```

<br/>

### ◼ HSQLDB
```sql
SELECT
  M.ID AS ID,
  M.AGE AS AGE,
  M.TEAM_ID AS TEAM_ID,
  M.NAME AS NAME
FROM
  MEMBER M
ORDER BY
  M.NAME DESC OFFSET ? LIMIT ?
```

<br/>

### ◼ MySQL
```sql
SELECT
  M.ID AS ID,
  M.AGE AS AGE,
  M.TEAM_ID AS TEAM_ID,
  M.NAME AS NAME
FROM
  MEMBER M
ORDER BY
  M.NAME DESC LIMIT ?, ?
```

<br/>

### ◼ PostgreSQL
```sql
SELECT
  M.ID AS ID,
  M.AGE AS AGE,
  M.TEAM_ID AS TEAM_ID,
  M.NAME AS NAME
FROM
  MEMBER M
ORDER BY
  M.NAME DESC OFFSET ? LIMIT ?
```

<br/>

### ◼ 오라클
```sql
SELECT *
FROM
  ( SELECT ROW_.*, ROWNUM ROWNUM_
  FROM
    ( SELECT
      M.ID AS ID,
      M.AGE AS AGE,
      M.TEAM_ID AS TEAM_ID,
      M.NAME AS NAME
    FROM MEMBER M
    ORDER BY M.NAME
    ) ROW_
  WHERE ROWNUM <= ?
  )
WHERE ROWNUM_ > ?
```

<br/>

### ◼ SQLServer
```sql
WITH qeury AS (
  SELECT
  inner_query.*,
  ROW_NUMBER() OVER (ORDER BY CURRENT_TIMESTAMP) as
    __hibernate_row_nr__
  FROM
    ( select
      TOP(?) m.id as id,
      m.age as age,
      m.team_id as team_id,
      m.name as name
    from Member m
    order by m.name DESC
    ) inner_query
)
SELECT id, age, team_id, name
FROM query
WHERE  __hibernate_row_nr__ >= ? AND  __hibernate_row_nr__ < ?
```
- 페이징 SQL을 더 최적화하고 싶다면 JPA가 제공하는 페이징 API가 아닌 네이티브 SQL을 직접 사용해야 한다.

<br/>

## 10.2.5 집합과 정렬
```sql
select
  COUNT(m),   // 회원수
  SUM(m.age), // 나이 합
  AVG(m.age), // 평균 나이
  MAX(m.age), // 최대 나이
  MIN(m.age)  // 최소 나이
from Member m
```

### ◼ 집합 함수

|함수|설명|
|:---|:---|
|COUNT|결과 수를 구한다. 반환 타입: Long|
|MAX, MIN|최대, 최소 값을 구한다. 문자, 숫자, 날짜 등에 사용한다.|
|AVG|평균값을 구한다. 숫자타입만 사용할 수 있다. 반환 타입: Double|
|SUM|합을 구한다. 숫자타입만 사용할 수 있다. 반환 타입: 정수합 Long, 소수합: Double, BigInteger합: BigInteger, BigDecimal합: BigDecimal|

- NULL 값은 무시하므로 통계에 잡히지 않는다
- 만약 값이 없는데 집합 함수를 사용하면 NULL 값이 된다. 단 COUNT는 0이 된다
- DISTINCT를 집합 함수 안에 사용해서 중복된 값을 제거하고 나서 집합을 구할 수 있다.
  - `select COUNT(DISTINCT m.age) from Member m`
- DISTINCT를 COUNT에서 사용할 때 임베디드 타입은 지원하지 않는다

<br/>

### ◼ GROUP BY, HAVING
```sql
select t.name, COUNT(m.age), SUM(m.age), AVG(m.age), MAX(m.age), MIN(m.age)
from Member m LEFT JOIN m.team t
GROUP BY t.name
HAVING AVG(m.age) >= 10
```
- GROUP BY는 통게 데이터를 구할 때 특정 그룹끼리 묶어준다.
- HAVING은 GROUP BY와 함께 사용하는데 GROUP BY로 그룹화한 통계 데이터를 기준으로 필터링한다.
- 통계쿼리는 보통 전체 데이터를 기준으로 처리하므로 실시간으로 사용하기엔 부담이 많다.
- 결과가 아주 많다면 통게 결과만 저장하는 테이블을 별도로 만들어 두고 사용자가 적은 새벽에 통계 쿼리를 실행해서 그 결과를 보관하는 것이 좋다.

<br/>

## 10.2.6 JPQL 조인

### ◼ 내부조인
- 내부조인은 INNER JOIN을 사용한다. INNER는 생략할 수 있다.
```java
String teamName = "팀A";
String query = "SELECT m FROM Member m INNER JOIN m.team t "
              + "WHERE t.name = :teamName";

List<Member> members = em.createQuery(query, Member.class
                          .setParameter("teamName", teamName)
                          .getResultList();
```
```sql
SELECT
  M.ID AS ID,
  M.AGE AS AGE,
  M.TEAM_ID AS TEAM_ID,
  M.NAME AS NAME
FROM
  MEMBER M INNER JOIN TEAM T ON M.TEAM_ID=T.ID
WHERE
  T.NAME=?
```
- JPQL 내부 조인 구문을 보면 SQL의 조인과 약간 다른 것을 확인할 수 있다.
- JPQL 조인의 가장 큰 특징은 연관 필드를 사용한다는 것이다. 여기서 m.team이 연관 필드인데 연관 필드는 다른 엔티티와 연관관계를 가지기 위해 사용하는 필드를 말한다.

<br/>

### ◼ 외부 조인
```java
SELECT m
FROM Member m LEFT [OUTER] JOIN m.team t
```

<br/>

### ◼ 컬렉션 조인
- 일대다 관계나 다대다 관계처럼 컬렉션을 사용하는 곳에 조인하는 것을 컬렉션 조인이라 한다.
- [회원->팀]으로의 조인은 다대일 조인이면서 단일 값 연관 필드(m.team)를 사용한다.
- [팀->회원]은 반대로 일대다 조인이면서 컬렉션 값 연관 필드(m.members)를 사용한다.
- `SELECT t, m FROM Team t LEFT JOIN t.members m`
- 여기서 t LEFT JOIN t.members`는 팀과 팀이 보유한 회원목록을 컬렉션 값 연관 필드로 외부 조인했다.

<br/>

### ◼ 세타 조인
- WHERE 절을 사용해서 세타 조인을 할 수 있다.
- 세타 조인은 내부 조인만 지원한다.
- 세타 조인을 사용하면 전혀 관계없는 엔티티도 조인할 수 있다.

```java
// 회원 이름이 팀 이름과 똑같은 사람 수를 구하는 예

// JPQL
select count(m) from Member m, Team t
where m.username = t.name

// SQL
SELECT COUNT(M.ID)
FROM
  MEMBER M CROSS JOIN TEAM T
WHERE
  M.USERNAME = T.NAME
```

<br/>

### ◼ JOIN ON 절
- ON 절을 사용하면 조인 대상을 필터링하고 조인할 수 있다.
- 내부 조인의 ON 절은 WHERE 절을 사용할 때와 결과가 같으므로 보통 ON 절은 외부 조인에서만 사용한다.
```java
// 모든 회원을 조회하면서 회원과 연관된 팀도 조회
// 이때 팀은 이름이 A인 팀만 조회

// JPQL
select m, t from Member m
left join m.team t on t.name = 'A'

// SQL
SELECT m.*, t.* FROM Member m
LEFT JOIN Team t ON m.TEAM_ID = t.id and t.name='A'
```

<br/>

## 102.7 페치 조인
- JPQL에서 성능 최적화를 위해 제공하는 기능이다
- 연관된 엔티티나 컬렉션을 한 번에 같이 조회하는 기능인데 join fetch 명령어로 사용할 수 있다

### ◼ 엔티티 페치 조인
```java
select m
from Member m join fetch m.team
```

```sql
SELECT
  M.*, T.*
FROM MEMBER M
INNER JOIN TEAM T ON M.TEAM_ID = T.ID
```

![image](https://github.com/user-attachments/assets/e01c7500-1998-4ec2-a096-21dab8cf7dec)

![image](https://github.com/user-attachments/assets/22513cf2-e81d-443a-94cb-1ac57b0b2722)
<br/>
(이미지 출처: https://ym1085.github.io/jpa/JPA-페치조인-기본/)

- 이렇게 하면 연관된 엔티티나 컬렉션을 함께 조회하는데 여기서는 회원과 팀을 함께 조회한다.
- 참고로 일반적인 JPQL 조인과는 다르게 m.team 다음에 별칭이 없는데 페치 조인은 별칭을 사용할 수 없다.
- 엔티티 페치 조인 JPQL에서 select m으로 회원 엔티티만 선택했는데 실행된 SQL을 보면 `SELECT M.*, T.*`로 회원과 연관된 팀도 함께 조회된 것을 확인할 수 있다.
- 또한 회원과 팀 객체가 객체 그래프를 유지하면서 조회된다.

```java
String jpql = "select m from Member m join fetch m.team";

List<Member> members = em.createQuery(jpql, Member.class)
                          .getResultList();

for (Member member:members) {
  // 페치 조인으로 회원과 팀을 함께 조회해서 지연 로딩 발생 안 함
  System.out.println("username = " + member.getUsername() + ", " + "teamname = "+member.getTeam().name());
}
```
```java
username = 회원1, teamname = 팀A
username = 회원2, teamname = 팀A
username = 회원3, teamname = 팀B
```
- 회원과 팀을 지연 로딩으로 설정했다고 가정해보자. 회원을 조회할 때 페치 조인을 사용해서 팀도 함께 조회했으므로 연관된 팀 엔티티는 프록시가 아닌 실제 에닡티다.
- 따라서 연관된 팀을 사용해도 지연 로딩이 일어나지 않는다.
- 그리고 프록시가 아닌 실제 엔티티이므로 회원 엔티티가 영속성 컨텍스트에서 분리되어 준영속 상태가 되어도 연관된 팀을 조회할 수 있다.

<br/>

### ◼ 컬렉션 페치 조인
- 일대다 관계인 컬렉션을 페치 조인해보자

```java
select t
from Team t join fetch t.members
where t.name = '팀A'
```

```sql
SELECT
  T.*, M.*
FROM TEAM T
INNER JOIN MEMBER M ON T.ID=M.TEAM_ID
WHERE T.NAME='팀A'
```

![image](https://github.com/user-attachments/assets/a2a0cedb-62ca-4331-b7b1-0fb6c9509dac)
<br/>
(이미지 출처: https://ym1085.github.io/jpa/JPA-페치조인-기본/)

- JPQL에서 select t로 팀만 선택했는데 SQL을 보면 T.*, M.*로 팀과 연관된 회원도 함께 조회한 것을 확인할 수 있다
- 일대다 조인은 결과가 증가할 수 있지만 일대일, 다대일 조인은 결과가 증가하지 않는다

```java
String jpql = "select t from Team t join fetch t.members where t.name = '팀A'";
List<Team> teams = em.createQuery(jpql, Team.class).getResultList();

for (Team team : teams) {

  System.out.println("teamname = "+team.getName()+", team = "+team);

  for (Member member : team.getMembers()) {
    // 페치 조인으로 팀과 회원을 함께 조회해서 지연 로딩 발생 안 함
    System.out.println("->username = " + member.getUsername() + ". member = "+member);
  }
}
```
```java
teamname = 팀A, team = Team@0x100
->username = 회원1, member = Member@0x200
->username = 회원2, member = Member@0x300
teamname = 팀A, team = Team@0x100
->username = 회원1, member = Member@0x200
->username = 회원2, member = Member@0x300
```

<br/>

### ◼ 페치 조인과 DISTINCT
- JPQL의 DISTINCT 명령어는 SQL에 DISTINCT를 추가하는 것은 물론이고 애플리케이션에서 한 번 더 중복을 제거한다.
- 바로 직전의 컬렉션 페치 조인은 팀A가 중복으로 조회된다. 다음처럼 DISTINCT를 추가해보자.

```java
select distinct t
from Team t join fetch t.members
where t.name = '팀A'
```
- 지금은 각 로우의 데이터가 다르므로 SQL의 DISTINCT 효과가 없다.
- 다음으로 애플리케이션에서 distinct 명령어를 보고 중복된 데이터를 걸러낸다.
- `select distinct t`의 의미는 팀 엔티티의 중복을 제거하라는 것이다.

![image](https://github.com/user-attachments/assets/6c8c57a3-e568-4a6e-bdc4-cfeb0dee7c47)
<br/>
(이미지 출처: https://ym1085.github.io/jpa/JPA-페치조인-기본/)

- 컬렉션 페치 조인 사용 예제에 distinct를 추가하면 출력 결과는 다음과 같다.

```java
teamname = 팀A, team = Team@0x100
->username = 회원1, member = Member@0x200
->username = 회원2, member = Member@0x300
```

<br/>

### ◼ 페치 조인과 일반 조인의 차이
- 일반 조인 시, JPQL에서 팀과 회원 컬렉션을 조인했으므로 회원 컬렉션도 함께 조회될 것으로 기대해선 안 된다.
- **JPQL은 결과를 반환할 때 연관관계까지 고려하지 않는다. 단지 SELECT 절에 저장한 엔티티만 조회할 뿐이다.**
- 따라서 팀 엔티티만 조회하고 연관된 회원 컬렉션은 조회하지 않는다.
- 만약 회원 컬렉션을 지연 로딩으로 설정하면 프록시나 초기화하지 않은 컬렉션 래퍼를 반환한다.
- 즉시 로딩으로 설정하면 회원 컬렉션을 즉시 로딩하기 위해 쿼리를 한 번 더 실행한다.
- 반면에 **페치 조인을 사용하면 연관된 엔티티도 함께 조회한다.**

<br/>

### ◼ 페치 조인의 특징과 한계
- 페치 조인을 사용하면 SQL 한 번으로 연관된 엔티티들을 함께 조회할 수 있어서 SQL 호출 횟수를 줄여 성능을 최적화 할 수 있다.
- 엔티티에 직접 적용하는 로딩 전략은 애플리케이션 전체에 영향을 미치므로 글로벌 로딩 전략이라 부른다.
- 페치 조인은 글로벌 로딩 전략보다 우선한다.
- **최적화를 위해 글로벌 로딩 전략을 즉시 로딩으로 설정하면 애플리케이션 전체에서 항상 즉시 로딩이 일어난다. 이는 사용하지 않는 엔티티 로딩을 초래해 성능에 악영향을 미칠 수 있다. 따라서 글로벌 로딩 전략은 될 수 있으면 지연 로딩을 사용하고 최적화가 필요하면 페치 조인을 적용하는 것이 효과적이다.**
- 페치 조인을 사용하면 연관된 에닡티를 쿼리 시점에 조회하므로 지연 로딩이 발생하지 않는다. 따라서 **준영속 상태에서도 객체 그래프를 탐색 할 수 있다.**
- 페치 조인은 다음과 같은 한계가 있다.
1. 페치 조인 대상에는 별칭을 줄 수 없다.
2. 둘 이상의 컬렉션을 페치할 수 없다.
3. 컬렉션을 페치 조인하면 페이징 API를 사용할 수 없다.
    - 컬렉션(일대다)이 아닌 단일 값 연관 필드(일대일, 다대일)들은 페치 조인을 사용해도 페이징 API를 사용할 수 있다.
    - 하이버네이트에서 컬렉션을 페치 조인하고 페이징 API를 사용하면 경고 로그를 남기면서 메모리에서 페이징 처리를 한다. 데이터가 적으면 상관 없겠지만 데이터가 많으면 성능 이슈와 메모리 초과 예외가 발생할 수 있어 위험하다.
- 페치 조인은 SQL 한 번으로 연관된 여러 엔티티를 조회할 수 있어서 성능 최적화에 상당히 유용하다.
- 페치 조인은 객체 그래프를 유지할 때 사용하면 효과적이다.
- 반면 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야 한다면 억지로 페치 조인을 사용하기보다는 여러 테이블에서 필요한 필드들만 조회해서 DTO로 반환하는 것이 더 효과적일 수 있다.

<br/>

## 10.2.8 경로 표현식
- 경로 표현식은 쉽게 이야기해서 점을 찍어 객체 그래프를 탐색하는 것이다.

### ◼ 경로 표현식의 용어 정리
- 상태 필드: 단순히 값을 저장하기 위한 필드
- 연관 필드: 연관관계를 위한 필드, 임베디드 타입 포함
  - 단일 값 연관 필드: `@ManyToOne`, `@OneToOne`, 대상이 엔티티
  - 컬렉션 값 연관 필드: `@OneToMany`, `@ManyToMany`, 대상이 컬렉션

<br/>

### ◼ 경로 표현식과 특징
1. 상태 필드 경로
    - 경로 탐색의 끝이다. 더는 탐색할 수 없다.
    - JPQL: `select m.username, m.age from Member m`
    - SQL: `select m.name, m.age from Member m`
2. 단일 값 연관 경로
    - **묵시적으로 내부 조인**이 일어난다. 단일 값 연관 경로는 계속 탐색할 수 있다.
    - JPQL: `select o.member from Order o`
    - SQL: `select m.* from Orders o inner join Member m on o.member_id = m.id`
    - 임베디드 타입에 접근하는 것도 단일 값 경로 탐색이지만 주문 테이블에 이미 포함되어 있으므로 조인이 발생하지 않는다.
3. 컬렉션 값 연관 경로
    - **묵시적으로 내부 조인**이 일어난다. 더는 탐색할 수 없다. 단 FROM 절에서 조인을 통해 별칭을 얻으면 별칭으로 탐색하 수 있다.
    - JPQL을 다루면서 만힝 하는 실수 중 하나는 컬렉션 값에서 경로 탐색을 시도하는 것이다.
    - `select t.members from Team t` (⭕)
    - `select t.members.username from Team t` (❌)
    - 만약 컬렉션에서 경로 탐색을 하고 싶으면 다음 코드처럼 조인을 사용해서 새로운 별칭을 획득해야 한다
    - `select m.username from Team t join t.members m`
    - `join t.members m`으로 컬렉션에 새로운 별칭을 얻었다. 이제 별칭 m부터 다시 경로 탐색을 할 수 있다.
