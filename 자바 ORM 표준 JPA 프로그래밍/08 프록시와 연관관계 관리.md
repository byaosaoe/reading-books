# 8.1 프록시
- 엔티티를 조회할 때 연관된 엔티티들이 항상 사용되는 것은 아니다.

- 회원 엔티티
```java
@Entity
public class Member {

  private String username;

  @ManyToOne
  private Team team;

  public Team getTeam() {
    return team;
  }

  public String getUsername() {
    return username;
  }
  ...
}
```

- 팀 엔티티

```java
@Entity
public class Team {

  private String name;

  public String getName() {
    return name;
  }
  ...
}
```

- 회원 엔티티만 사용하는 메서드에서 팀 엔티티까지 데이터베이스에서 함께 조회해 두는 것은 효율적이지 않다.
- JPA는 이런 문제를 해결하려고 엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연하는 방법을 제공하는데 이것을 **지연 로딩**이라 한다.
- 쉽게 이야기해서 엔티티의 값을 실제 사용하는 시점에 데이터베이스에서 필요한 데이터를 조회하는 것이다.
- 그런데 지연 로딩 기능을 사용하려면 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요한데 이것을 **프록시 객체**라 한다.
- JPA 표준 명세는 지연 로딩의 구현 방법을 JPA 구현체에 위임했다.

<br/>

## 8.1.1 프록시 기초
- JPA에서 식별자로 엔티티 하나를 조회할 때는 `EntityManager.find()`를 사용한다. 이 메소드는 영속성 컨텍스트에 엔티티가 없으면 데이터베이스를 조회한다.
- 이렇게 엔티티를 직접 조회하면 조회한 엔티티를 실제 사용하든 사용하지 않든 데이터베이스를 조회하게 된다.
- 엔티티를 실제 사용하는 시점까지 데이터베이스 조회를 미루고 싶으면 `EntityManager.getReference()` 메소드를 사용하면 된다.
- 이 메소드를 호출할 때 JPA는 데이터베이스를 조회하지 않고 실제 엔티티 객체도 생성하지 않는다. 대신 데이터베이스 접근을 위임한 프록시 객체를 반환한다.

### ◼ 프록시의 특징
- 프록시 클래스는 실제 클래스를 상속 받아서 만들어지므로 실제 클래스와 겉 모양이 같다.
- 사용하는 입장에서는 이것이 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다.
- 프록시 객체는 실제 객체에 대한 참조를 보관한다.
- 프록시 객체의 메소드를 호출하면 프록시 객체는 실제 객체의 메소드를 호출한다.

### ◼ 프록시 객체의 초기화
- 프록시 객체는 실제 사용될 때 데이터베이스를 조회해서 실제 엔티티 객체를 생성하는데 이것을 프록시 객체의 초기화라 한다.

```java
Member member = em.getReference(Member.class, "id1");
member.getName();
```

1. 프록시 객체의 메서드를 호출해서 실제 데이터를 조회한다.
2. 프록시 객체는 실제 엔티티가 생성되어 있지 않으면 영속성 컨텍스트에 실제 엔티티 생성을 요청하는데 이것을 초기화라 한다.
3. 영속성 컨텍스트는 데이터베이스를 조회해서 실제 엔티티 객체를 생성한다.
4. 프록시 객체는 생성된 실제 엔티티 객체의 참조를 멤버변수에 보관한다.
5. 프록시 객체는 실제 엔티티 객체의 메서드를 호출해서 결과를 반환한다.

### ◼ 프록시의 특징
- 프록시 객체는 처음 사용할 때 한 번만 초기화된다.
- 프록시 객체를 초기화한다고 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다. 프록시 객체가 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근할 수 있다.
- 프록시 객체는 원본 엔티티를 상속받은 객체이므로 타입 체크 시에 주의해서 사용해야 한다.
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 데이터베이스를 조회할 필요가 없으므로 `em.getReference()`를 호출해도 프록시가 아닌 실제 엔티티를 반환한다.
- 초기화는 영속성 컨텍스트의 도움을 받아야 가능하다. 따라서 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태의 프록시를 초기화하면 문제가 발생한다.

### ◼ 준영속 상태와 초기화
```java
// MemberProxy 반환
Member member = em.getReference(Member.class, "id1");
transaction.commit();
em.close();

member.getName(); // org.hibernate.LazyInitializationException 예외 발생
```
- 영속성 컨텍스트가 종료된 상태에서 준영속 상태가 된 `member`의 메소드를 호출하면 프록시를 초기화해야 하는데 영속성 컨텍스트가 없으므로 실제 엔티티를 조회할 수 없다. 따라서 예외가 발생한다.

<br/>

## 8.1.2 프록시와 식별자
- 엔티티를 프록시로 조회할 때 식별자 값을 파라미터로 전달하는데 프록시 객체는 이 식별자 값을 보관한다.
- 프록시 객체는 식별자 값을 가지고 잇으므로 식별자 값을 조회하는 `team.getId()`를 호출해도 프록시를 초기화하지 않는다.
- 단 엔티티 접근 방식을 프로퍼티(`@Access(AccessType.PROPERTY)`)로 설정한 경우에만 초기화하지 않는다.
- 엔티티 접근 방식을 필드(`@Access(AccessType.FIELD)`)로 설정하면 JPA는 `getId()` 메소드가 id만 조회하는 메소드인지 다른 필드까지 활용해서 어떤 일을 하는 메소드인지 알지 못하므로 프록시 객체를 초기화한다.
- 프록시는 연관관계를 설정할 때 유용하게 사용할 수 있다.
```java
Member member = em.find(Member.class, "member1");
Team team = em.getReference(Team.class, "team1");
member.setTeam(team);
```
- 연관관계를 설정할 때는 식별자 값만 사용하므로 프록시를 사용하면 데이터베이스 접근 횟수를 줄일 수 있다.
- 연관관계를 설정할 때는 엔티티 접근 방식을 필드로 설정해도 프록시를 초기화하지 않는다.

<hr/>

# 8.2 즉시 로딩과 지연 로딩
- 프록시 객체는 주로 연관된 엔티티를 지연 로딩할 때 사용한다.
1. 즉시 로딩: 엔티티를 조회할 때 연관된 엔티티도 함께 조회한다.
    - 설정 방법: `@ManyToOne(fetch=FetchType.EAGER)`
2. 지연 로딩: 연관된 엔티티를 실제 사용할 때 조회한다.
    - 설정 방법: `@ManyToOne(fetch=FetchType.LAZY)`
  
<br/>

## 8.2.1 즉시 로딩
- 즉시 로딩으로 설정하면 회원을 조회하는 순간 팀도 함께 조회한다.
- 이때 회원과 팀 두 테이블을 조회해야 하므로 쿼리를 2번 실행할 것 같지만, 대부분의 JPA 구현체는 즉시 로딩을 최적화하기 위해 가능하면 조인 쿼리를 사용한다.
- 여기서는 회원과 팀을 조인해서 쿼리 한 번으로 두 엔티티를 모두 조회한다.

### NULL 제약조건과 JPA 조인 전략
- 외래키가 NULL 값을 허용하는 경우, 멤버는 존재하지만 팀은 존재하지 않는데 이때 내부조인을 사용하면 존재하지만 조회되지 않는 멤버 데이터가 있을 수 있다.
- JPA는 이런 상황을 고려해서 외부 조인을 사용한다.
- 하지만 외부 조인보다 내부 조인이 성능과 최적화에서 더 유리하다.
- 외래키에 NOT NULL 제약 조건을 설정하면 값이 있는 것을 보장한다. 따라서 이때는 내부 조인만 사용해도 된다.
- `@JoinColumn(nullable=false)`를 설정해서 이 사실을 JPA에게도 알리면 JPA는 외부 조인 대신에 내부 조인을 사용한다.
- 또는 `@ManyToOne.optional = false`로 설정해도 내부 조인을 사용한다.
- 정리하자면 JPA는 선택적 관계면 외부 조인을 사용하고 필수 관계면 내부 조인을 사용한다.

<br/>

## 8.2.2 지연 로딩
- 지연 로딩으로 설정된 엔티티를 조회하면 해당 엔티티만 조회되고 연관 엔티티는 조회되지 않는다.
- 대신 조회한 엔티티의 멤버변수에 프록시 객체를 넣어둔다.
```java
Team team = member.getTeam();
```
- 반환된 팀 객체는 프록시 객체다. 이 프록시 객체는 실제 사용될 때까지 데이터 로딩을 미룬다. 그래서 지연 로딩이라 한다.
- 실제 데이터가 필요한 순간이 되어서야 데이터베이스를 조회해서 프록시 객체를 초기화한다.
- 조회 대상이 영속성 컨텍스트에 이미 있으면 프록시 객체를 사용할 이유가 없다. 따라서 프록시가 아닌 실제 객체를 사용한다.

<br/>

8.2.3 즉시 로딩, 지연 로딩 정리
- 모든 엔티티를 즉시 로딩하는 것은 현실적이지 않고, 모든 엔티티를 지연 로딩 하는 것 또한 최적화 관점에서 보면 꼭 좋은 것만은 아니다.
- 대부분의 애플리케이션 로직에서 회원과 팀 엔티티를 같이 사용한다면 SQL 조인을 사용해서 회원과 팀 엔티티를 한 번에 조회하는 것이 더 효율적이다.
- 결국 연관된 엔티티를 즉시 로딩하는 것이 좋은지 아니면 실제 사용할 때까지 지연해서 로딩하는 것이 좋은지는 상황에 따라 다르다.

<hr/>

# 8.3 지연 로딩 활용
